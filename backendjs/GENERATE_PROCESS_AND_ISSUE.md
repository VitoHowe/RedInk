# 图片生成流程与 TaskID 同步问题分析

本文档详细说明了 `/generate` 接口的工作流程，并分析了当前架构中存在的 `task_id` 同步问题。

## 1. `/generate` 接口工作流程

### 1.1 请求接收

- **接口**: `POST /generate`
- **参数**:
  - `pages`: 页面数据列表
  - `task_id`: (可选) 任务ID
  - `full_outline`: 完整大纲
  - `user_topic`: 用户主题
  - `user_images`: 用户参考图片

### 1.2 历史记录关联 (关键步骤)

后端尝试将当前生成任务关联到已存在的历史记录：

1.  **检查参数**: 查看请求中是否携带了 `task_id`。
2.  **查找记录**: 如果有 `task_id`，遍历所有历史记录 (`history/index.json`)。
3.  **匹配逻辑**: 寻找 `record.images.task_id === request.task_id` 的记录。
4.  **关联结果**:
    - **找到**: 获取 `recordId`，后续生成过程会实时更新该记录的状态和图片列表。
    - **未找到**: `recordId` 为 null，生成过程**不会**更新任何历史记录。

### 1.3 图片生成 (SSE 流式)

1.  **初始化**:
    - 如果请求未提供 `task_id`，后端自动生成一个新的 UUID。
    - 创建任务目录 `history/{task_id}/`。
2.  **生成封面**:
    - 调用 AI 生成封面图。
    - 如果关联了 `recordId`，更新历史记录的 `thumbnail` 字段。
3.  **生成内容页**:
    - 并发或顺序生成其余页面。
    - 每生成一张，如果关联了 `recordId`，实时更新历史记录的 `images.generated` 列表。
4.  **完成**:
    - 更新历史记录状态为 `completed` 或 `partial`。

## 2. 发现的问题：TaskID 的“先有鸡还是先有蛋”

### 问题描述

在当前的业务流程中，存在一个逻辑死锁，导致生成的图片无法自动关联到历史记录。

**当前流程：**

1.  **生成大纲**: 用户调用 `/outline`。
2.  **保存记录**: 用户点击保存，前端调用 `/history`。
    - 此时前端通常**没有** `task_id`。
    - 后端创建历史记录，`task_id` 为 `null`。
3.  **生成图片**: 用户点击生成，前端调用 `/generate`。
    - 前端没有 `task_id`，请求参数中不传或传空。
    - 后端 `ImageService` 自动生成一个新的 `task_id` (例如 `task_abc123`)。
    - **关键失效点**: 后端尝试用这个新生成的 `task_id` 去查找历史记录，显然**找不到**（因为历史记录里是 `null`）。
    - **结果**: 图片能生成，但**不会**保存到历史记录中，用户刷新页面后看不到生成的图片。

### 根本原因

后端 `/generate` 接口依赖 `task_id` 来反向查找历史记录 (`record_id`)，但 `task_id` 是在生成阶段才产生的（或者由前端生成），而历史记录是在此之前创建的。

## 3. 解决方案建议

为了修复这个问题，有以下两种推荐方案：

### 方案 A：前端主导 TaskID (推荐)

由前端负责生成 `task_id`，并贯穿整个流程。

1.  **生成大纲后**：前端生成一个 UUID 作为 `task_id`。
2.  **调用 `/history`**：将这个 `task_id` 传给后端，后端保存到记录中。
3.  **调用 `/generate`**：将同一个 `task_id` 传给后端。
    - 后端根据 `task_id` 就能成功找到第2步创建的记录，从而实现关联。

### 方案 B：后端支持 RecordID

修改 `/generate` 接口，允许直接传递 `record_id`。

1.  **调用 `/history`**：后端返回创建的 `record_id`。
2.  **调用 `/generate`**：前端将 `record_id` 放入请求参数。
3.  **后端修改**：
    - `src/routes/api.ts` 中增加对 `record_id` 参数的解析。
    - 直接使用传入的 `record_id`，跳过通过 `task_id` 查找的步骤。
    - 如果请求没传 `task_id`，后端生成后，还需要反向更新该 `record_id` 对应的 `task_id` 字段。

## 4. 结论

目前的实现存在缺陷，**必须**采用上述方案之一进行修复，否则“保存大纲 -> 生成图片”这一流程将导致数据断链。**方案 A (前端生成 ID)** 改动最小，逻辑最清晰。

## 5. 问题修复记录 (2025-11-29)

已通过 **方案 B (后端支持 RecordID)** 修复此问题，同时兼容方案 A。

### 修复内容

1.  **修改 `/generate` 接口**:
    - 新增 `record_id` 参数支持。
    - 优先使用前端传入的 `record_id`。
    - 如果未传 `record_id` 但有 `task_id`，后端会尝试反向查找历史记录（兼容旧逻辑）。
    - 如果两者都无，则视为新任务，不关联历史记录。

2.  **流程优化**:
    - 前端在调用 `/generate` 时，应从 Store 中获取当前大纲对应的 `recordId` 并传入。
    - 后端接收到 `record_id` 后，直接将其传递给 `ImageService`。
    - `ImageService` 在生成封面和每一页图片时，会实时更新该 `record_id` 对应的历史记录。

### 验证状态

- [x] 后端接口已更新 (`src/routes/api.ts`)。
- [x] `ImageService` 已支持 `recordId` 参数。
- [x] 历史记录关联逻辑已修复。
